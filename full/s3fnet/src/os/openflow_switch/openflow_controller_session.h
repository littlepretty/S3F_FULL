/**
 * \file openflow_controller_session.h
 * \brief Header file for the OpenFlowControllerSession class and all its child classes (e.g., LearningControllerSession).
 *
 * authors : Dong (Kevin) Jin
 */

#ifndef __OPENFLOW_CONTROLLER_SESSION_H__
#define __OPENFLOW_CONTROLLER_SESSION_H__

#include "openflow_switch_session.h"
#include "os/base/protocol_session.h"

namespace s3f {
namespace s3fnet {

class OpenFlowSwitchSession;
class StatsDumpCallback;
class Host;
class NetworkInterface;

#define OF_CONTROLLER_PROTOCOL_CLASSNAME "S3F.OS.OPENFLOW_CONTROLLER"
#define OF_CONTROLLER_LEARNING_SWITCH_PROTOCOL_CLASSNAME "S3F.OS.OPENFLOW_CONTROLLER_LEARNING_SWITCH"

/**
 * \brief An interface for an entity-based OpenFlow controller.
 * A controller is implemented as ProtocolSession, and it follows the OpenFlow specification for a controller.
 */
class OpenFlowControllerSession : public ProtocolSession
{
public:
	/** constructor */
	OpenFlowControllerSession(ProtocolGraph* graph);

	/** destructor */
	virtual ~OpenFlowControllerSession ();

	/** each protocol must have a unique protocol number */
	virtual int getProtocolNumber() { return S3FNET_PROTOCOL_TYPE_OPENFLOW_CONTROLLER; }

	/** called to configure this protocol session */
	virtual void config(s3f::dml::Configuration* cfg);

	/** called after config() to initialize this protocol session */
	virtual void init();

	/** called by other protocol sessions to send special control messages */
	virtual int control(int ctrltyp, void* ctrlmsg, ProtocolSession* sess);

	/** called by the protocol session above to push a protocol message down the protocol stack */
	virtual int push(Activation msg, ProtocolSession* hi_sess, void* extinfo = 0, std::size_t extinfo_size = 0);

	/** called by the protocol session below to pop a protocol message up the protocol stack */
	virtual int pop(Activation msg, ProtocolSession* lo_sess, void* extinfo = 0, size_t extinfo_size = 0);

	/**
	 * Adds a switch to the controller.
	 *
	 * \param swtch The switch to register.
	 */
	virtual void AddSwitch (OpenFlowSwitchSession* swtch);

	/**
	 * A switch calls this method to pass a message on to the Controller.
	 *
	 * \param swtch The switch the message was received from.
	 * \param buffer The message.
	 */
	virtual void ReceiveFromSwitch (OpenFlowSwitchSession* swtch, ofpbuf* buffer) {}

	/**
	 * Handle the inquiry message from OpenFlow switches, the rest switch->controller messages (e.g., error) is handled by ReceiveFromSwitch()
	 *
	 * \param pkt incoming inquiry packet from OpenFlow switches.
	 * \param incoming_iface the network interface through which the packet is received.
	 */
	virtual void HandleInquiryMessageFromOFSwitch(Activation pkt, NetworkInterface* incoming_iface) {}

	/**
	 * \brief Starts a callback-based, reliable, possibly multi-message reply to a request made by the controller.
	 *
	 * If an incoming request needs to have a reliable reply that might
	 * require multiple messages, it can use StartDump() to set up
	 * a callback that will be called as buffer space for replies.
	 *
	 * A stats request made by the controller is processed by the switch,
	 * the switch then calls this method to tell the controller to start
	 * asking for information. By default (it can be overridden), the
	 * controller stops all work to run through the callback. ReceiveFromSwitch
	 * must be defined appropriately to handle the status reply messages
	 * generated by the switch, or otherwise the status reply messages will be sent
	 * and discarded.
	 *
	 * \param cb The callback data.
	 */
	void StartDump (StatsDumpCallback* cb);

	int type; ///< model of the controller, e.g., learning_switch

protected:
	/**
	 * \internal
	 *
	 * However the controller is implemented, this method is to
	 * be used to pass a message on to a switch.
	 *
	 * \param swtch The switch to receive the message.
	 * \param msg The message to send.
	 * \param length The length of the message.
	 */
	virtual void SendToSwitch (OpenFlowSwitchSession* swtch, void * msg, size_t length);

	/**
	 * \internal
	 *
	 * Construct flow data from a matching key to build a flow
	 * entry for adding, modifying, or deleting a flow.
	 *
	 * \param key The matching key data; used to create a flow that matches the packet.
	 * \param buffer_id The OpenFlow Buffer ID; used to run the actions on the packet if we add or modify the flow.
	 * \param command Whether to add, modify, or delete this flow.
	 * \param acts List of actions to execute.
	 * \param actions_len Length of the actions buffer.
	 * \param idle_timeout Flow expires if left inactive for this amount of time (specify OFP_FLOW_PERMANENT to disable feature).
	 * \param hard_timeout Flow expires after this amount of time (specify OFP_FLOW_PERMANENT to disable feature).
	 * \return Flow data that when passed to SetFlow will add, modify, or delete a flow it defines.
	 */
	ofp_flow_mod* BuildFlow (sw_flow_key key, uint32_t buffer_id, uint16_t command, void* acts, size_t actions_len, int idle_timeout, int hard_timeout);

	/**
	 * \internal
	 *
	 * Get the packet type on the buffer, which can then be used
	 * to determine how to handle the buffer.
	 *
	 * \param buffer The packet in OpenFlow buffer format.
	 * \return The packet type, as defined in the ofp_type struct.
	 */
	uint8_t GetPacketType (ofpbuf* buffer);

	typedef std::set<OpenFlowSwitchSession* > Switches_t;
	Switches_t m_switches;  ///< The collection of switches registered to this controller.
};

/**
 * Demonstration of a Learning controller. When a connected switch
 * passes it a packet the switch doesn't recognize, the controller
 * delves into its learned states and figures out if we know what
 * port the packet is supposed to go to, flooding if unknown, and
 * adjusts the switch's flow table accordingly.
 */
class LearningControllerSession : public OpenFlowControllerSession
{
public:
	/** constructor */
	LearningControllerSession (ProtocolGraph* graph);

	/** destructor */
	virtual ~LearningControllerSession ();

	/**
	 * A switch calls this method to pass a message on to the Controller.
	 *
	 * \param swtch The switch the message was received from.
	 * \param buffer The message.
	 */
	void ReceiveFromSwitch (OpenFlowSwitchSession* swtch, ofpbuf* buffer);

	/**
	 * Handle the inquiry message from OpenFlow switches, the rest switch->controller messages (e.g., error) is handled by ReceiveFromSwitch()
	 *
	 * \param pkt incoming inquiry packet from OpenFlow switches.
	 * \param incoming_iface the network interface through which the packet is received.
	 */
	void HandleInquiryMessageFromOFSwitch(Activation pkt, NetworkInterface* incoming_iface);

	/**
	 * Adds a switch to the controller.
	 *
	 * \param swtch The switch to register.
	 */
	void AddSwitch (OpenFlowSwitchSession* swtch);

	/** set the flow expiration time, which indicates how long a flow is valid in the flow table. No expiration time by default. */
	void setFlowExpirationTime(ltime_t time);

	/** get the flow expiration time. */
	ltime_t getFlowExpirationTime();

protected:
	struct LearnedState
	{
		uint32_t port;                      ///< Learned port.
	};
	ltime_t m_expirationTime;                ///< Time it takes for learned MAC state entry/created flow to expire.

	typedef S3FNET_MAP(Mac48Address, LearnedState) LearningTable; //learning table per switch
	typedef S3FNET_MAP(OpenFlowSwitchSession*, LearningTable) Tables; //all tables

	Tables tables; ///< all learning tables, one table per openflow switch
};

}; // namespace s3fnet
}; // namespace s3f

#endif /* __OPENFLOW_CONTROLLER_SESSION_H__ */
