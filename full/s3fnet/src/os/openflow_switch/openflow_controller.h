/**
 * \file openflow_controller.h
 * \brief Header file for the Controller class and all its child classes (e.g., LearningController and DropController).
 *
 * authors : Dong (Kevin) Jin
 */

#ifndef __OPENFLOW_CONTROLLER_H__
#define __OPENFLOW_CONTROLLER_H__

#include "openflow_switch_session.h"

namespace s3f {
namespace s3fnet {

class OpenFlowSwitchSession;
class StatsDumpCallback;
class Host;

/**
 * \brief An interface for a non-entity-based OpenFlow controller.
 *
 * Switches and the controller interact through direct function calls.
 * It follows the OpenFlow specification for a controller.
 */
class Controller
{
public:

	Controller();

	virtual ~Controller ()
	{
		m_switches.clear ();
	}

	/**
	 * Adds a switch to the controller.
	 *
	 * \param swtch The switch to register.
	 */
	virtual void AddSwitch (OpenFlowSwitchSession* swtch);

	/**
	 * A switch calls this method to pass a message on to the Controller.
	 *
	 * \param swtch The switch the message was received from.
	 * \param buffer The message.
	 */
	virtual void ReceiveFromSwitch (OpenFlowSwitchSession* swtch, ofpbuf* buffer) {}

	/**
	 * \brief Starts a callback-based, reliable, possibly multi-message reply to a request made by the controller.
	 *
	 * If an incoming request needs to have a reliable reply that might
	 * require multiple messages, it can use StartDump() to set up
	 * a callback that will be called as buffer space for replies.
	 *
	 * A stats request made by the controller is processed by the switch,
	 * the switch then calls this method to tell the controller to start
	 * asking for information. By default (it can be overridden), the
	 * controller stops all work to run through the callback. ReceiveFromSwitch
	 * must be defined appropriately to handle the status reply messages
	 * generated by the switch, or otherwise the status reply messages will be sent
	 * and discarded.
	 *
	 * \param cb The callback data.
	 */
	void StartDump (StatsDumpCallback* cb);

	int type; ///< model of the controller, e.g., learning_switch

protected:
	/**
	 * \internal
	 *
	 * However the controller is implemented, this method is to
	 * be used to pass a message on to a switch.
	 *
	 * \param swtch The switch to receive the message.
	 * \param msg The message to send.
	 * \param length The length of the message.
	 */
	virtual void SendToSwitch (OpenFlowSwitchSession* swtch, void * msg, size_t length);

	/**
	 * \internal
	 *
	 * Construct flow data from a matching key to build a flow
	 * entry for adding, modifying, or deleting a flow.
	 *
	 * \param key The matching key data; used to create a flow that matches the packet.
	 * \param buffer_id The OpenFlow Buffer ID; used to run the actions on the packet if we add or modify the flow.
	 * \param command Whether to add, modify, or delete this flow.
	 * \param acts List of actions to execute.
	 * \param actions_len Length of the actions buffer.
	 * \param idle_timeout Flow expires if left inactive for this amount of time (specify OFP_FLOW_PERMANENT to disable feature).
	 * \param hard_timeout Flow expires after this amount of time (specify OFP_FLOW_PERMANENT to disable feature).
	 * \return Flow data that when passed to SetFlow will add, modify, or delete a flow it defines.
	 */
	ofp_flow_mod* BuildFlow (sw_flow_key key, uint32_t buffer_id, uint16_t command, void* acts, size_t actions_len, int idle_timeout, int hard_timeout);

	/**
	 * \internal
	 *
	 * Get the packet type on the buffer, which can then be used
	 * to determine how to handle the buffer.
	 *
	 * \param buffer The packet in OpenFlow buffer format.
	 * \return The packet type, as defined in the ofp_type struct.
	 */
	uint8_t GetPacketType (ofpbuf* buffer);

	typedef std::set<OpenFlowSwitchSession* > Switches_t;
	Switches_t m_switches;  ///< The collection of switches registered to this controller.
};

/**
 * A controller that builds a flow for each received packet to drop all packets it matches
 * (this demonstrates the flow table's basic implementation).
 *
 * When a connected switch passes it a packet that the switch doesn't recognize,
 * the controller configures the switch to make a flow that drops alike packets.
 *
 */
class DropController : public Controller
{
public:

	/**
	 * A switch calls this method to pass a message on to the Controller.
	 *
	 * \param swtch The switch the message was received from.
	 * \param buffer The message.
	 */
	void ReceiveFromSwitch (OpenFlowSwitchSession* swtch, ofpbuf* buffer);
};

/**
 * Demonstration of a Learning controller. When a connected switch
 * passes it a packet the switch doesn't recognize, the controller
 * delves into its learned states and figures out if we know what
 * port the packet is supposed to go to, flooding if unknown, and
 * adjusts the switch's flow table accordingly.
 */
class LearningController : public Controller
{
public:
	/** constructor */
	LearningController();

	/** destructor */
	virtual ~LearningController ();

	/**
	 * A switch calls this method to pass a message on to the Controller.
	 *
	 * \param swtch The switch the message was received from.
	 * \param buffer The message.
	 */
	void ReceiveFromSwitch (OpenFlowSwitchSession* swtch, ofpbuf* buffer);

	/**
	 * process the received packet from a OpenFlow switch
	 *
	 * \param swtch The switch the message was received from.
	 * \param buffer The message.
	 */
	void process_recv_packet(OpenFlowSwitchSession* swtch, ofpbuf* buffer);

	/**
	 * Adds a switch to the controller.
	 *
	 * \param swtch The switch to register.
	 */
	void AddSwitch (OpenFlowSwitchSession* swtch);

	/** set the flow expiration time, which indicates how long a flow is valid in the flow table. No expiration time by default. */
	void setFlowExpirationTime(ltime_t time);

	/** get the flow expiration time. */
	ltime_t getFlowExpirationTime();

protected:
	struct LearnedState
	{
		uint32_t port;                      ///< Learned port.
	};
	ltime_t m_expirationTime;                ///< Time it takes for learned MAC state entry/created flow to expire.
	typedef S3FNET_MAP(Mac48Address, LearnedState) LearningTable; //learning table per switch
	typedef S3FNET_MAP(OpenFlowSwitchSession*, LearningTable) Tables; //all tables

	Tables tables; ///< all learning tables, one table per openflow switch
};

}; // namespace s3fnet
}; // namespace s3f

#endif /* __OPENFLOW_CONTROLLER_H__ */
